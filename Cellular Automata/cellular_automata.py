# -*- coding: utf-8 -*-
"""Cellular_Automata.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11UVpyL-VMap21_jwWAe7D5-25e77fwdL
"""

import numpy as np
import pickle
import matplotlib.pyplot as plt

"""**Step 1: Rule Encoding**"""

def encode_rule(rule_number):
    """Encodes a rule number into a binary dictionary for quick lookup."""
    binary_representation = f"{rule_number:08b}"
    return {i: int(binary_representation[::-1][i]) for i in range(8)}

"""**Step 2: Apply Rules**"""

def apply_rule(state, rule, lambda_param):
    """
    Apply the diploid rule to the cellular automaton.
    :param state: Current state of the cells (numpy array).
    :param rule: Tuple (f1_dict, f2_dict) containing encoded rules.
    :param lambda_param: Probability of applying f2 over f1.
    :return: Updated state.
    """
    f1, f2 = rule
    n = len(state)
    new_state = np.zeros_like(state)

    # Get neighborhood values
    left_neighbors = np.roll(state, 1)
    right_neighbors = np.roll(state, -1)

    # Compute next state for each cell
    for i in range(n):
        neighborhood = (left_neighbors[i] << 2) | (state[i] << 1) | right_neighbors[i]
        if np.random.rand() < lambda_param:
            new_state[i] = f2[neighborhood]
        else:
            new_state[i] = f1[neighborhood]

    return new_state

"""**Step 3: Parallel Simulation**"""

from multiprocessing import Pool

def simulate_step(args):
    """
    Helper function to apply a rule to a segment of the automaton.
    This will be used for parallel processing.
    """
    state, rule, lambda_param = args
    return apply_rule(state, rule, lambda_param)

def run_simulation_parallel(n_cells=10000, n_steps=5000, f1_rule=0, f2_rule=110, lambda_param=0.5, n_threads=4):
    """
    Simulate diploid cellular automata with parallel processing.
    :param n_cells: Number of cells in the automaton.
    :param n_steps: Number of time steps.
    :param f1_rule: Rule number for f1 (e.g., 0 for the null rule).
    :param f2_rule: Rule number for f2 (e.g., 110).
    :param lambda_param: Probability parameter for applying f2.
    :param n_threads: Number of threads for parallel processing.
    :return: History of states during the simulation.
    """
    # Initialize the grid
    state = np.random.choice([0, 1], size=n_cells)

    # Encode rules
    f1 = encode_rule(f1_rule)
    f2 = encode_rule(f2_rule)
    rule = (f1, f2)

    # Run simulation
    history = [state.copy()]
    with Pool(n_threads) as pool:
        for _ in range(n_steps):
            # Divide the state into chunks for parallel processing
            chunk_size = len(state) // n_threads
            chunks = [state[i:i + chunk_size] for i in range(0, len(state), chunk_size)]
            results = pool.map(simulate_step, [(chunk, rule, lambda_param) for chunk in chunks])

            # Combine the updated chunks back into the full state
            state = np.concatenate(results)
            history.append(state.copy())

    return np.array(history)

"""**Step 4: Plotting**"""

def plot_density_vs_time(density_22, density_110, n_steps):
    """Plot densities as a function of time for Rule 22 and Rule 110."""
    plt.figure(figsize=(12, 6))
    plt.plot(density_22, label="Rule 22", color="blue")
    plt.plot(density_110, label="Rule 110", color="red")
    plt.xlabel("Time Steps")
    plt.ylabel("Density")
    plt.title(f"Densities as a Function of Time for Rule 22 and Rule 110 (λ = 0.8, {n_steps} Steps)")
    plt.legend()
    plt.grid(True)
    plt.show()

"""**Step 5: Running the Simulations**"""

if __name__ == "__main__":
    lambda_param = 0.8
    n_cells = 1000
    n_steps = 500
    n_threads = 4

    # Rule 22
    history_22_parallel = run_simulation_parallel(
        n_cells=n_cells, n_steps=n_steps, f1_rule=0, f2_rule=22, lambda_param=lambda_param, n_threads=n_threads
    )
    density_22_parallel = np.mean(history_22_parallel, axis=1)

    # Rule 110
    history_110_parallel = run_simulation_parallel(
        n_cells=n_cells, n_steps=n_steps, f1_rule=0, f2_rule=110, lambda_param=lambda_param, n_threads=n_threads
    )
    density_110_parallel = np.mean(history_110_parallel, axis=1)

    # Plot densities
    plot_density_vs_time(density_22_parallel, density_110_parallel, n_steps)

"""**Step 6: Code to Compute Final Densities for
λ Sweep**
"""

def compute_final_densities(n_cells=10000, n_steps=5000, f1_rule=0, f2_rule=22, lambda_range=None, n_threads=4):
    """
    Compute final densities for a range of lambda values.
    :param n_cells: Number of cells in the automaton.
    :param n_steps: Number of time steps.
    :param f1_rule: Rule number for f1 (e.g., 0 for the null rule).
    :param f2_rule: Rule number for f2 (e.g., 22 or 110).
    :param lambda_range: List of lambda values to sweep.
    :param n_threads: Number of threads for parallel processing.
    :return: List of final densities corresponding to lambda_range.
    """
    if lambda_range is None:
        lambda_range = np.linspace(0, 1, 21)  # Default: 21 values from 0 to 1

    final_densities = []
    for lambda_param in lambda_range:
        history = run_simulation_parallel(
            n_cells=n_cells, n_steps=n_steps, f1_rule=f1_rule, f2_rule=f2_rule, lambda_param=lambda_param, n_threads=n_threads
        )
        final_density = np.mean(history[-1])  # Final density of 1s
        final_densities.append(final_density)

    return final_densities

"""**Step 7: Plotting Final Densities**"""

def plot_final_densities(lambda_range, densities_22, densities_110):
    """Plot final densities as a function of lambda for Rules 22 and 110."""
    plt.figure(figsize=(12, 6))
    plt.plot(lambda_range, densities_22, label="Rule 22", marker="o", color="blue")
    plt.plot(lambda_range, densities_110, label="Rule 110", marker="o", color="red")
    plt.xlabel("Lambda (λ)")
    plt.ylabel("Final Density")
    plt.title("Final Densities as a Function of λ for Rule 22 and Rule 110")
    plt.legend()
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    n_cells = 1000
    n_steps = 500
    n_threads = 4
    lambda_range = np.linspace(0, 1, 21)  # 21 equally spaced values from 0 to 1

    # Rule 22
    densities_22 = compute_final_densities(n_cells=n_cells, n_steps=n_steps, f1_rule=0, f2_rule=22,
                                           lambda_range=lambda_range, n_threads=n_threads)

    # Rule 110
    densities_110 = compute_final_densities(n_cells=n_cells, n_steps=n_steps, f1_rule=0, f2_rule=110,
                                            lambda_range=lambda_range, n_threads=n_threads)

    # Plot results
    plot_final_densities(lambda_range, densities_22, densities_110)

"""**Part 2: Choice Task of Asynchronous CA**

**Step 1: Updated Rule Application for Asynchronous CA**
"""

def apply_asynchronous_rule(state, rule, alpha_param):
    """
    Apply the asynchronous rule to the cellular automaton.
    :param state: Current state of the cells (numpy array).
    :param rule: Tuple (f1_dict, f2_dict) containing encoded rules.
    :param alpha_param: Probability of applying f1 over f2.
    :return: Updated state.
    """
    f1, f2 = rule
    n = len(state)
    new_state = np.zeros_like(state)

    # Get neighborhood values
    left_neighbors = np.roll(state, 1)
    right_neighbors = np.roll(state, -1)

    # Compute next state for each cell
    for i in range(n):
        neighborhood = (left_neighbors[i] << 2) | (state[i] << 1) | right_neighbors[i]
        if np.random.rand() < alpha_param:
            new_state[i] = f1[neighborhood]  # Apply f1
        else:
            new_state[i] = f2[neighborhood]  # Apply f2

    return new_state

"""**Step 2: Asynchronous Simulation**"""

def run_asynchronous_simulation(n_cells=1000, n_steps=1000, f1_rule=6, alpha_param=0.5, n_threads=4):
    """
    Simulate asynchronous cellular automata with parallel processing.
    :param n_cells: Number of cells in the automaton.
    :param n_steps: Number of time steps.
    :param f1_rule: Rule number for f1 (e.g., 6, 50, 178).
    :param alpha_param: Probability parameter for applying f1.
    :param n_threads: Number of threads for parallel processing.
    :return: History of states during the simulation.
    """
    # Initialize the grid
    state = np.random.choice([0, 1], size=n_cells)

    # Encode rules
    f1 = encode_rule(f1_rule)
    f2 = encode_rule(204)  # Identity rule
    rule = (f1, f2)

    # Run simulation
    history = [state.copy()]
    with Pool(n_threads) as pool:
        for _ in range(n_steps):
            # Divide the state into chunks for parallel processing
            chunk_size = len(state) // n_threads
            chunks = [state[i:i + chunk_size] for i in range(0, len(state), chunk_size)]
            results = pool.map(simulate_step, [(chunk, rule, alpha_param) for chunk in chunks])

            # Combine the updated chunks back into the full state
            state = np.concatenate(results)
            history.append(state.copy())

    return np.array(history)

"""**Step 3: Space-Time Diagrams**"""

def plot_space_time(history, title="Space-Time Diagram"):
    """Plot the space-time diagram of the automaton."""
    plt.figure(figsize=(12, 6))
    plt.imshow(history, cmap="binary", aspect="auto")
    plt.xlabel("Cells")
    plt.ylabel("Time Steps")
    plt.title(title)
    plt.show()

"""**Execution Example**"""

if __name__ == "__main__":
    n_cells = 1000
    n_steps = 500
    alpha_values = [0.25, 0.5, 0.75]
    rules = [6, 50, 178]

    for f1_rule in rules:
        for alpha in alpha_values:
            history = run_asynchronous_simulation(n_cells=n_cells, n_steps=n_steps, f1_rule=f1_rule, alpha_param=alpha)
            plot_space_time(history, title=f"Rule {f1_rule}, α = {alpha}")

"""**Step 4: Compute Equilibrium Densities**"""

def compute_equilibrium_densities_asynchronous(n_cells=1000, n_steps=1000, f1_rule=6, alpha_range=None, n_threads=4):
    """
    Compute equilibrium densities for a range of alpha values.
    :param n_cells: Number of cells in the automaton.
    :param n_steps: Number of time steps.
    :param f1_rule: Rule number for f1 (e.g., 6 or 50).
    :param alpha_range: List of alpha values to sweep.
    :param n_threads: Number of threads for parallel processing.
    :return: List of final densities corresponding to alpha_range.
    """
    if alpha_range is None:
        alpha_range = np.linspace(0, 1, 21)  # Default: 21 values from 0 to 1

    final_densities = []
    for alpha_param in alpha_range:
        history = run_asynchronous_simulation(
            n_cells=n_cells, n_steps=n_steps, f1_rule=f1_rule, alpha_param=alpha_param, n_threads=n_threads
        )
        final_density = np.mean(history[-1])  # Density at equilibrium
        final_densities.append(final_density)

    return final_densities

"""**Step 5: Plot Densities**"""

def plot_equilibrium_densities(alpha_range, densities_6, densities_50):
    """Plot equilibrium densities as a function of alpha."""
    plt.figure(figsize=(12, 6))
    plt.scatter(alpha_range, densities_6, label="Rule 6", marker="o", color="blue")
    plt.scatter(alpha_range, densities_50, label="Rule 50", marker="o", color="red")
    plt.xlabel("Alpha (α)")
    plt.ylabel("Equilibrium Density")
    plt.title("Equilibrium Density vs Alpha for Rule 6 and Rule 50")
    plt.legend()
    plt.grid(True)
    plt.show()

"""**Execution**"""

if __name__ == "__main__":
    n_cells = 1000
    n_steps = 1000
    n_threads = 4
    alpha_range = np.linspace(0, 1, 21)  # 21 equally spaced values from 0 to 1

    # Compute densities for Rule 6
    densities_6 = compute_equilibrium_densities_asynchronous(
        n_cells=n_cells, n_steps=n_steps, f1_rule=6, alpha_range=alpha_range, n_threads=n_threads
    )

    # Compute densities for Rule 50
    densities_50 = compute_equilibrium_densities_asynchronous(
        n_cells=n_cells, n_steps=n_steps, f1_rule=50, alpha_range=alpha_range, n_threads=n_threads
    )

    # Plot results
    plot_equilibrium_densities(alpha_range, densities_6, densities_50)

